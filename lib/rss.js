const Promise = require('bluebird');
const _ = require('lodash');
const moment = require('moment');
const debug = require('debug')('lib:rss');
const nconf= require('nconf');
const RSS = require('rss');
const path = require('path');
const fs = Promise.promisifyAll(require('fs'));

const utils = require('../lib/utils');
const echoes = require('../lib/echoes');
const mongo = require('../lib/mongo');

const fbtrexRSSdescription = "This newsfeed is generated by the distributed observation of Facebook posts, collected with https://facebook.tracking.exposed browser extension; The posts are processed with a technical proceduce called semantic analysis, it extract the core meanings of the post linkable to existing wikipedia pages";
const fbtrexRSSproblem = "We can't provide a newsfeed on the information you requested. This is, normally, due because you look for a keyword which has not been seen recently. We permit to generate RSS only about voices which are part of wikipedia because this ensure we do not enable any kind of stalking. (editing wikipedia would not work). You can really use only label which are meaningful encyclopedic voices";

function buildXML(lang, label, enriched) {

    if(!_.size(enriched))
        return {
            lang,
            label,
            content: produceError(lang, label, `Not found "${label}" in the last 7 days`)
        };

    const language = _.first(_.first(enriched).labels).lang;
    const title = `fbTREX ‚è© ${lang} ‚àï ${label}`;
    const composed = new RSS({
        title,
        description: fbtrexRSSdescription,
        generator: `fbtrexRSS, algorithm version 0`,
        feed_url: `https://facebook.tracking.exposed/feeds/0/${lang}/${encodeURIComponent(label)}`,
        ttl: 60
    });

    /* > _.keys(_.first(enriched)) 
       > [ '_id', 'summary', 'labels' ]              */
    _.each(enriched, function(e) {
        try {
            composed.item(appendItem(e))
        } catch(error) {
            debug("--- Impossible to add an item: %s", error.message);
        }
    });
    debug("Generated RSS (%d bytes, from %d posts) for [%s] %s",
        _.size(composed.xml()), _.size(enriched), lang, label);

    return {
        lang,
        label,
        content: composed.xml()
    };
}

function appendItem(e) {
    /* every entry is an enriched post,
     * this function creates an RSS post (a.k.a item for RSS format) */
    const summary = _.first(e.summary);
    const labels = _.first(e.labels);

    const printableTime = summary.publicationTime ? summary.publicationTime : moment();
    const vdiff = summary.publicationTime ? 
        "in " + moment.duration(
            moment(summary.impressionTime) -
            moment(summary.publicationTime) 
        ).humanize() : null;

    const images = (summary.images && summary.images.count) ? `${summary.images.count} img` : null;
    const opti = _.reduce({
        'LIKE'  :   'üëç',
        'LOVE'  :   '‚ù§',
        'ANGRY' :   'üí¢',
        'WOW'   :   'üí°',
        'SAD'   :   'üò¢',
        'HAHA'  :   'üòÑ' }, function(memo, emoji, rname) {
            var amount = _.get(summary, rname);
            if(_.isUndefined(amount))
                return memo;
            memo.push(`${emoji} ${amount}`);
            return memo;
    }, [ images, vdiff ]);

    const infot = _.compact(opti).join('‚çò');
    const title = `[${summary.source} üñâ ${summary.textsize}] ${infot}`;
    const tldr = _.reduce(summary.texts, function(memo, o) {
        memo += `‚Üí ${o}\r\n`;
        return memo;
    }, "");
    const link = (summary.opengraph && summary.opengraph.isValid) ? `‚û≠ ${summary.opengraph.link}\r\n` : "";
    const formattedText = `\r\n${tldr}\r\n\r\n${link}`;
    const concepts = `\r\n‚áâ ${_.uniq(labels.l).join(', ')}\r\n`;

    let permaLink = null;
    if(_.isNull(summary.permaLink)) {
        permaLink = summary.postId ? `https://facebook.com/${summary.postId}` : "https://facebook.tracking.exposed/fbtrexRSS#problem";
    } else if(!_.startsWith(summary.permaLink, '/')) {
        debug("permaLink do not start with '/': %s", summary.permaLink);
        permaLink = summary.permaLink;
    } else {
        permaLink = summary.permaLink ? `https://facebook.com${summary.permaLink}` : postIdLink;
    }

    /* this is the item format expected by RSS */
    return {
        title,
        description: `${formattedText}${concepts}`,
        url: permaLink,
        guid: summary.semanticId,
        date: printableTime,
     };
}

function produceError(lang, label, note) {
    const url = lang ?
        `https://facebook.tracking.exposed/feeds/0/${lang}/${encodeURIComponent(label)}` :
        "https://facebook.tracking.exposed/fbtrexRSS";

    let feed = new RSS({
        title: `fbTREX ‚ìç  Error: ${note}`,
        description: `There is an error in your requested feed: ${note}`,
        feed_url: url,
        ttl: 20
    });
    feed.item({
        title: `fbTREX ‚ìç  Error: ${note}`,
        description : fbtrexRSSproblem,
        guid: 1234567890,
        date: moment().toISOString()
    });
    return feed.xml();
};

function composeRSSfeed(lang, title, amount) {
    const builderFunction = _.partial(buildXML, lang, title);
    return mongo
        .aggregate(nconf.get('schema').semantics, [
            { $match: { lang: lang, label: title }},
            { $sort: { when: -1 }},
            { $limit: amount },
            { $group: { _id: "$semanticId" }},
            { $lookup: { from: 'summary', localField: '_id', foreignField: 'semanticId', as: 'summary' }},
            { $lookup: { from: 'labels', localField: '_id', foreignField: 'semanticId', as: 'labels' }}
        ])
        .then(builderFunction)
        .tap(function(entry) {
            // reminder, this works because there is an expiration date on the object 
            return mongo
                .writeOne(nconf.get('schema').feeds, {
                    lang: entry.lang,
                    label: entry.label,
                    createdAt: new Date(),
                    content: entry.content,
                })
        })
        .then(function(entry) {
            debug("Saved in cache the RSS request");
            return { text: entry.content };
        });
};


module.exports = {
    composeRSSfeed,
    produceError,
};
